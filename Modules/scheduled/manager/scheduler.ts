/**
 * Scheduler - Timer management for reminders and scheduled messages
 */

import {
  Client,
  TextChannel,
  MessageFlags,
  PermissionFlagsBits,
  EmbedBuilder,
  MessageCreateOptions,
  Guild,
  ContainerBuilder,
  TextDisplayBuilder,
  MediaGalleryBuilder,
  MediaGalleryItemBuilder,
} from 'discord.js';
import { getModuleSetting } from '@internal/utils/settings/settingsStorage';
import type { SettingValue } from '@bot/types/settingsTypes';
import { resolveEmojisInText } from '@internal/utils/emojiHandler';
import { UserReminder, ScheduledGroup, EmbedBehavior, MessageDesign, TextFormat } from '../types/scheduled';
import {
  deleteReminder,
  getAllReminders,
  loadReminders,
  getAllGroups,
  getGroup,
  updateGroup,
  markMessageSent,
  updateLastPinnedMessage,
} from '../utils/storage';
import { selectNextMessage } from './selection';

const MODULE_NAME = 'scheduled';
const CATEGORY = 'misc';

// Active timers
const reminderTimers = new Map<string, NodeJS.Timeout>();
const groupTimers = new Map<string, NodeJS.Timeout>();

// Max setTimeout value (~24.8 days)
const MAX_TIMEOUT = 2147483647;

function getSetting<T extends SettingValue>(key: string, guildId: string, defaultValue: T): T {
  const value = getModuleSetting<T>(MODULE_NAME, key, guildId, CATEGORY);
  return value !== undefined ? value : defaultValue;
}

// ================== REMINDER SCHEDULING ==================

export function scheduleReminder(client: Client, reminder: UserReminder): void {
  const existing = reminderTimers.get(reminder.id);
  if (existing) clearTimeout(existing);

  const delay = reminder.triggerAt - Date.now();

  if (delay <= 0) {
    deliverReminder(client, reminder);
    return;
  }

  if (delay > MAX_TIMEOUT) {
    // Re-check later
    const timer = setTimeout(() => scheduleReminder(client, reminder), MAX_TIMEOUT);
    reminderTimers.set(reminder.id, timer);
    return;
  }

  const timer = setTimeout(() => deliverReminder(client, reminder), delay);
  reminderTimers.set(reminder.id, timer);
}

async function deliverReminder(client: Client, reminder: UserReminder): Promise<void> {
  reminderTimers.delete(reminder.id);

  try {
    const channel = await client.channels.fetch(reminder.channelId) as TextChannel | null;
    if (!channel || !channel.isTextBased()) {
      deleteReminder(reminder.guildId, reminder.id);
      return;
    }

    // Try to delete original confirmation message
    try {
      const originalMessage = await channel.messages.fetch(reminder.messageId);
      await originalMessage.delete();
    } catch {
      // Message may already be deleted
    }

    // Get message templates
    const reminderTemplate = getSetting('reminder.reminderMessage', reminder.guildId, '{ping} Reminder!\n> {message}');
    const footer = getSetting('reminder.footer', reminder.guildId, '-# *This message was generated by the user using `/reminder`*');
    const embedBehavior = getSetting<EmbedBehavior>('reminder.embedBehavior', reminder.guildId, 'with_perms');

    // Build the reminder message
    let content = reminderTemplate
      .replace('{ping}', `<@${reminder.userId}>`)
      .replace('{message}', reminder.message);

    if (footer) {
      content += `\n${footer}`;
    }

    // Determine if we should suppress embeds
    let suppressEmbeds = false;

    if (embedBehavior === 'never') {
      suppressEmbeds = true;
    } else if (embedBehavior === 'with_perms') {
      // Check if user has EmbedLinks permission
      try {
        const member = await channel.guild.members.fetch(reminder.userId);
        const perms = channel.permissionsFor(member);
        if (!perms?.has(PermissionFlagsBits.EmbedLinks)) {
          suppressEmbeds = true;
        }
      } catch {
        // If we can't check, suppress by default
        suppressEmbeds = true;
      }
    }
    // 'always' = don't set flags, embeds will show

    // Send the reminder
    await channel.send({
      content,
      flags: suppressEmbeds ? MessageFlags.SuppressEmbeds : undefined,
      allowedMentions: { users: [reminder.userId] },
    });

    // Delete from storage
    deleteReminder(reminder.guildId, reminder.id);
  } catch (error) {
    console.error('[Scheduled] Reminder delivery error:', error);
    deleteReminder(reminder.guildId, reminder.id);
  }
}

export function cancelReminder(reminderId: string): void {
  const timer = reminderTimers.get(reminderId);
  if (timer) {
    clearTimeout(timer);
    reminderTimers.delete(reminderId);
  }
}

// ================== PIN MANAGEMENT ==================

/**
 * Verify a message exists and is pinned, then unpin it
 * Returns true if successfully unpinned, false otherwise
 */
export async function verifyAndUnpinMessage(
  client: Client,
  channelId: string,
  messageId: string
): Promise<boolean> {
  try {
    const channel = await client.channels.fetch(channelId) as TextChannel | null;
    if (!channel || !channel.isTextBased()) {
      console.log(`[Scheduled] Cannot unpin: Channel ${channelId} not found or not text-based`);
      return false;
    }

    // Try to fetch the message
    let message;
    try {
      message = await channel.messages.fetch(messageId);
    } catch {
      console.log(`[Scheduled] Cannot unpin: Message ${messageId} not found in channel ${channelId}`);
      return false;
    }

    // Check if the message is actually pinned
    if (!message.pinned) {
      console.log(`[Scheduled] Message ${messageId} exists but is not pinned, skipping unpin`);
      return false;
    }

    // Unpin the message
    await message.unpin();
    console.log(`[Scheduled] Successfully unpinned message ${messageId}`);
    return true;
  } catch (error) {
    console.error(`[Scheduled] Error verifying/unpinning message ${messageId}:`, error);
    return false;
  }
}

// ================== GROUP SCHEDULING ==================

export function scheduleGroup(client: Client, group: ScheduledGroup): void {
  const existing = groupTimers.get(group.id);
  if (existing) clearTimeout(existing);

  if (!group.enabled || !group.nextSendAt) return;

  const delay = group.nextSendAt - Date.now();

  if (delay <= 0) {
    sendScheduledMessage(client, group);
    return;
  }

  if (delay > MAX_TIMEOUT) {
    const timer = setTimeout(() => scheduleGroup(client, group), MAX_TIMEOUT);
    groupTimers.set(group.id, timer);
    return;
  }

  const timer = setTimeout(() => sendScheduledMessage(client, group), delay);
  groupTimers.set(group.id, timer);
}

/**
 * Handle auto-pin: unpin old message, pin new message
 * Uses stored channel ID for unpinning to handle channel changes correctly
 */
async function handleAutoPin(
  client: Client,
  channel: TextChannel,
  group: ScheduledGroup,
  newMessageId: string
): Promise<void> {
  try {
    // Unpin previous if exists - use stored channel ID (may differ from current channel)
    if (group.lastPinnedMessageId) {
      const unpinChannelId = group.lastPinnedChannelId || group.channelId;
      await verifyAndUnpinMessage(client, unpinChannelId, group.lastPinnedMessageId);
    }

    // Pin new message
    const newMessage = await channel.messages.fetch(newMessageId);
    await newMessage.pin();
    updateLastPinnedMessage(group.guildId, group.id, newMessageId, channel.id);
    console.log(`[Scheduled] Pinned new message ${newMessageId} in channel ${channel.id}`);
  } catch (error) {
    console.error('[Scheduled] Failed to handle auto-pin:', error);
  }
}

/**
 * Apply text formatting to content
 */
function applyTextFormats(content: string, formats: TextFormat[] | undefined): string {
  if (!formats || formats.length === 0) return content;

  let formatted = content;

  // Apply formats in a specific order to avoid conflicts
  // Note: Some formats are mutually exclusive in practice

  if (formats.includes('codeblock')) {
    // Code block wraps everything
    formatted = `\`\`\`\n${formatted}\n\`\`\``;
  } else {
    // These can be combined (except with codeblock)
    if (formats.includes('code')) {
      formatted = `\`${formatted}\``;
    }
    if (formats.includes('spoiler')) {
      formatted = `||${formatted}||`;
    }
    if (formats.includes('strikethrough')) {
      formatted = `~~${formatted}~~`;
    }
    if (formats.includes('underline')) {
      formatted = `__${formatted}__`;
    }
    if (formats.includes('italic')) {
      formatted = `*${formatted}*`;
    }
    if (formats.includes('bold')) {
      formatted = `**${formatted}**`;
    }
    if (formats.includes('quote')) {
      // Quote each line
      formatted = formatted.split('\n').map(line => `> ${line}`).join('\n');
    }
  }

  return formatted;
}

/**
 * Build message options with design applied (title/footer, message vs embed)
 */
function buildMessageWithDesign(
  content: string,
  design: MessageDesign | undefined,
  messageImage: string | undefined,
  client: Client,
  guild: Guild
): MessageCreateOptions {
  // Resolve emoji shortcodes (title/footer/prefix are NOT formatted, only content is)
  let resolvedContent = resolveEmojisInText(content, client, guild);
  const resolvedTitle = design?.title ? resolveEmojisInText(design.title, client, guild) : undefined;
  const resolvedFooter = design?.footer ? resolveEmojisInText(design.footer, client, guild) : undefined;
  const resolvedPrefix = design?.prefix ? resolveEmojisInText(design.prefix, client, guild) : undefined;

  // Apply text formatting ONLY to the main content (not title/footer/prefix)
  resolvedContent = applyTextFormats(resolvedContent, design?.formats);

  // Check if we should use embed (Components V2)
  if (design?.messageType === 'embed') {
    const container = new ContainerBuilder();

    // Set accent color if specified
    if (design.color !== undefined) {
      container.setAccentColor(design.color);
    }

    // Prefix - at the top of the container, unformatted
    if (resolvedPrefix) {
      container.addTextDisplayComponents(
        new TextDisplayBuilder().setContent(resolvedPrefix)
      );
    }

    // Title - plain text, unformatted
    if (resolvedTitle) {
      container.addTextDisplayComponents(
        new TextDisplayBuilder().setContent(resolvedTitle)
      );
    }

    // Main content - with formatting applied
    container.addTextDisplayComponents(
      new TextDisplayBuilder().setContent(resolvedContent)
    );

    // Images - separate galleries so each displays at full size (message image first)
    if (messageImage) {
      container.addMediaGalleryComponents(
        new MediaGalleryBuilder().addItems(
          new MediaGalleryItemBuilder().setURL(messageImage)
        )
      );
    }
    if (design.image) {
      container.addMediaGalleryComponents(
        new MediaGalleryBuilder().addItems(
          new MediaGalleryItemBuilder().setURL(design.image)
        )
      );
    }

    // Footer - plain text, unformatted
    if (resolvedFooter) {
      container.addTextDisplayComponents(
        new TextDisplayBuilder().setContent(resolvedFooter)
      );
    }

    // Components V2 doesn't allow content field
    return {
      components: [container],
      flags: MessageFlags.IsComponentsV2,
    };
  }

  // Regular message: build final content
  let finalContent = resolvedContent;

  // Prepend prefix
  if (resolvedPrefix) {
    finalContent = `${resolvedPrefix}${finalContent}`;
  }

  // Prepend title
  if (resolvedTitle) {
    finalContent = `${resolvedTitle}\n${finalContent}`;
  }

  // Append footer
  if (resolvedFooter) {
    finalContent = `${finalContent}\n${resolvedFooter}`;
  }

  return { content: finalContent };
}

async function sendScheduledMessage(client: Client, group: ScheduledGroup): Promise<void> {
  groupTimers.delete(group.id);

  try {
    const channel = await client.channels.fetch(group.channelId) as TextChannel | null;
    if (!channel || !channel.isTextBased()) {
      console.error(`[Scheduled] Channel ${group.channelId} not found for group ${group.id}`);
      return;
    }

    // Select next message
    const message = selectNextMessage(group);
    if (!message) {
      // No more messages (loop disabled and all messages sent)
      updateGroup(group.guildId, group.id, { enabled: false });
      return;
    }

    // Build message with design applied
    const guild = channel.guild;
    const messageOptions = buildMessageWithDesign(message.content, group.design, message.image, client, guild);

    // Send the message
    const sentMessage = await channel.send(messageOptions);

    // Handle auto-pin
    if (group.autoPin) {
      await handleAutoPin(client, channel, group, sentMessage.id);
    }

    // Mark message as sent
    markMessageSent(group.guildId, group.id, message.id);

    // Calculate next send time
    const nextSendAt = calculateNextSend(group.schedule, Date.now());

    // Update and continue scheduling
    const updatedGroup = updateGroup(group.guildId, group.id, { nextSendAt });

    if (updatedGroup && updatedGroup.enabled && nextSendAt) {
      scheduleGroup(client, updatedGroup);
    }
  } catch (error) {
    console.error('[Scheduled] Send scheduled message error:', error);
  }
}

export function cancelGroup(groupId: string): void {
  const timer = groupTimers.get(groupId);
  if (timer) {
    clearTimeout(timer);
    groupTimers.delete(groupId);
  }
}

/**
 * Send a scheduled message immediately (Send Now feature)
 * @param skipNext - If true, push the next scheduled time by one interval
 */
export async function sendNow(client: Client, group: ScheduledGroup, skipNext: boolean = false): Promise<boolean> {
  try {
    const channel = await client.channels.fetch(group.channelId) as TextChannel | null;
    if (!channel || !channel.isTextBased()) {
      console.error(`[Scheduled] Channel ${group.channelId} not found for group ${group.id}`);
      return false;
    }

    // Select next message
    const message = selectNextMessage(group);
    if (!message) {
      return false;
    }

    // Build message with design applied
    const guild = channel.guild;
    const messageOptions = buildMessageWithDesign(message.content, group.design, message.image, client, guild);

    // Send the message
    const sentMessage = await channel.send(messageOptions);

    // Handle auto-pin
    if (group.autoPin) {
      await handleAutoPin(client, channel, group, sentMessage.id);
    }

    // Mark message as sent
    markMessageSent(group.guildId, group.id, message.id);

    // If skipNext is true, recalculate the next send time from the CURRENT nextSendAt
    // This pushes the schedule forward by one interval (skips the upcoming scheduled time)
    if (skipNext && group.enabled) {
      const newNextSendAt = calculateNextSend(group.schedule, group.nextSendAt || Date.now());
      updateGroup(group.guildId, group.id, { nextSendAt: newNextSendAt });

      // Reschedule the timer
      const updatedGroup = getGroup(group.guildId, group.id);
      if (updatedGroup) {
        cancelGroup(group.id);
        scheduleGroup(client, updatedGroup);
      }
    }

    return true;
  } catch (error) {
    console.error('[Scheduled] Send now error:', error);
    return false;
  }
}

// ================== SCHEDULE CALCULATION ==================

/**
 * Convert user's local time to UTC timestamp
 * User inputs timeHour:timeMinute in their local timezone.
 * We need to calculate when that is in UTC.
 *
 * If user is at UTC-3 and wants 12:00 local:
 * - Their local time is 3 hours behind UTC
 * - So 12:00 local = 15:00 UTC
 * - Formula: UTC = local - utcOffset (where offset is negative for UTC-3)
 */
function localTimeToUTC(
  baseDate: Date,
  timeHour: number,
  timeMinute: number,
  utcOffset: number,
  minuteModifier: number
): Date {
  // Convert user's local time to UTC
  // Total offset in minutes: if UTC-3, this is -180
  const totalOffsetMinutes = utcOffset * 60 + minuteModifier;

  // Target time in minutes past midnight (in user's local time)
  const localMinutes = timeHour * 60 + timeMinute;

  // Convert to UTC minutes (subtract offset because UTC = local - offset)
  // For UTC-3: UTC = local - (-180) = local + 180
  let utcMinutes = localMinutes - totalOffsetMinutes;

  // Start with the base date at midnight UTC
  const result = new Date(Date.UTC(
    baseDate.getUTCFullYear(),
    baseDate.getUTCMonth(),
    baseDate.getUTCDate(),
    0, 0, 0, 0
  ));

  // Handle day rollover
  while (utcMinutes < 0) {
    utcMinutes += 24 * 60;
    result.setUTCDate(result.getUTCDate() - 1);
  }
  while (utcMinutes >= 24 * 60) {
    utcMinutes -= 24 * 60;
    result.setUTCDate(result.getUTCDate() + 1);
  }

  result.setUTCHours(Math.floor(utcMinutes / 60), utcMinutes % 60, 0, 0);
  return result;
}

/**
 * Get the day of week in user's local timezone
 */
function getLocalDayOfWeek(timestamp: number, utcOffset: number, minuteModifier: number): number {
  const offsetMs = (utcOffset * 60 + minuteModifier) * 60 * 1000;
  const localDate = new Date(timestamp + offsetMs);
  return localDate.getUTCDay();
}

export function calculateNextSend(schedule: ScheduledGroup['schedule'], fromTime: number = Date.now()): number | null {
  const { type, timeHour, timeMinute, utcOffset, minuteModifier } = schedule;
  const now = new Date(fromTime);

  let nextDate: Date;

  switch (type) {
    case 'hourly': {
      const intervalHours = schedule.intervalHours || 1;
      // For hourly, start from the next occurrence of the target minute
      nextDate = new Date(fromTime);
      nextDate.setUTCSeconds(0, 0);

      // Adjust minute to target, accounting for timezone
      const totalOffsetMinutes = utcOffset * 60 + minuteModifier;
      let targetMinuteUTC = timeMinute - (totalOffsetMinutes % 60);
      if (targetMinuteUTC < 0) targetMinuteUTC += 60;
      if (targetMinuteUTC >= 60) targetMinuteUTC -= 60;

      nextDate.setUTCMinutes(targetMinuteUTC);

      // Find next occurrence
      while (nextDate.getTime() <= fromTime) {
        nextDate.setTime(nextDate.getTime() + intervalHours * 60 * 60 * 1000);
      }
      break;
    }

    case 'daily': {
      nextDate = localTimeToUTC(now, timeHour, timeMinute, utcOffset, minuteModifier);
      if (nextDate.getTime() <= fromTime) {
        nextDate.setUTCDate(nextDate.getUTCDate() + 1);
      }
      break;
    }

    case 'weekly': {
      const weekdays = schedule.weekdays || [0]; // Default Sunday
      nextDate = localTimeToUTC(now, timeHour, timeMinute, utcOffset, minuteModifier);

      // Find next matching weekday
      let found = false;
      for (let i = 0; i < 8; i++) {
        const checkDate = new Date(nextDate);
        checkDate.setUTCDate(nextDate.getUTCDate() + i);
        // Get day of week in user's local timezone
        const localDay = getLocalDayOfWeek(checkDate.getTime(), utcOffset, minuteModifier);

        if (weekdays.includes(localDay)) {
          nextDate.setUTCDate(nextDate.getUTCDate() + i);
          if (nextDate.getTime() > fromTime) {
            found = true;
            break;
          }
        }
      }
      if (!found) {
        nextDate.setUTCDate(nextDate.getUTCDate() + 7);
      }
      break;
    }

    case 'monthly': {
      const dayOfMonth = schedule.dayOfMonth || 1;
      // Create date with the target day of month
      const targetDate = new Date(Date.UTC(
        now.getUTCFullYear(),
        now.getUTCMonth(),
        dayOfMonth,
        0, 0, 0, 0
      ));
      nextDate = localTimeToUTC(targetDate, timeHour, timeMinute, utcOffset, minuteModifier);

      if (nextDate.getTime() <= fromTime) {
        targetDate.setUTCMonth(targetDate.getUTCMonth() + 1);
        targetDate.setUTCDate(dayOfMonth);
        nextDate = localTimeToUTC(targetDate, timeHour, timeMinute, utcOffset, minuteModifier);
      }
      break;
    }

    case 'custom': {
      const intervalMinutes = schedule.intervalMinutes || 0;
      const intervalHours = schedule.intervalHours || 0;
      const intervalDays = schedule.intervalDays || 0;

      // Calculate total interval in milliseconds
      const totalMs = (
        (intervalDays * 24 * 60) +      // Days to minutes
        (intervalHours * 60) +           // Hours to minutes
        intervalMinutes                  // Minutes
      ) * 60 * 1000;                     // Minutes to milliseconds

      // If total is 0, default to 1 day
      const actualMs = totalMs > 0 ? totalMs : 24 * 60 * 60 * 1000;

      nextDate = localTimeToUTC(now, timeHour, timeMinute, utcOffset, minuteModifier);
      while (nextDate.getTime() <= fromTime) {
        nextDate.setTime(nextDate.getTime() + actualMs);
      }
      break;
    }

    default:
      return null;
  }

  // Check end date
  if (schedule.endDate && nextDate.getTime() > schedule.endDate) {
    return null;
  }

  return nextDate.getTime();
}

// ================== INITIALIZATION ==================

export function initializeScheduler(client: Client): void {
  // Load all guilds from data and schedule existing items
  const { listGuilds } = require('@internal/utils/dataManager');

  const guildIds = listGuilds();
  let reminderCount = 0;
  let groupCount = 0;

  for (const guildId of guildIds) {
    // Schedule reminders
    const reminders = getAllReminders(guildId);
    for (const reminder of reminders) {
      scheduleReminder(client, reminder);
      reminderCount++;
    }

    // Schedule groups
    const groups = getAllGroups(guildId).filter(g => g.enabled && g.nextSendAt);
    for (const group of groups) {
      scheduleGroup(client, group);
      groupCount++;
    }
  }

  if (reminderCount > 0 || groupCount > 0) {
    console.log(`[Scheduled] Initialized ${reminderCount} reminders, ${groupCount} scheduled groups`);
  }
}
